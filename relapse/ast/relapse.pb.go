// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: relapse.proto

/*
	Package ast is a generated protocol buffer package.

	It is generated from these files:
		relapse.proto

	It has these top-level messages:
		Grammar
		PatternDecl
		Pattern
		Empty
		TreeNode
		Contains
		LeafNode
		Concat
		Or
		And
		ZeroOrMore
		Reference
		Not
		ZAny
		Optional
		Interleave
		Expr
		List
		Function
		BuiltIn
		Terminal
		Variable
		Keyword
		Space
		NameExpr
		Name
		AnyName
		AnyNameExcept
		NameChoice
*/
package ast

import proto "github.com/gogo/protobuf/proto"
import fmt "fmt"
import math "math"
import _ "github.com/gogo/protobuf/gogoproto"
import types "github.com/katydid/katydid/relapse/types"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Grammar is the ast node representing the whole grammar.
type Grammar struct {
	TopPattern   *Pattern       `protobuf:"bytes,1,opt,name=TopPattern" json:"TopPattern,omitempty"`
	PatternDecls []*PatternDecl `protobuf:"bytes,2,rep,name=PatternDecls" json:"PatternDecls,omitempty"`
	After        *Space         `protobuf:"bytes,3,opt,name=After" json:"After,omitempty"`
}

func (m *Grammar) Reset()                    { *m = Grammar{} }
func (*Grammar) ProtoMessage()               {}
func (*Grammar) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{0} }

func (m *Grammar) GetTopPattern() *Pattern {
	if m != nil {
		return m.TopPattern
	}
	return nil
}

func (m *Grammar) GetPatternDecls() []*PatternDecl {
	if m != nil {
		return m.PatternDecls
	}
	return nil
}

func (m *Grammar) GetAfter() *Space {
	if m != nil {
		return m.After
	}
	return nil
}

// PatternDecl is the ast node for the declaration of a pattern.
type PatternDecl struct {
	Hash    *Keyword `protobuf:"bytes,1,opt,name=Hash" json:"Hash,omitempty"`
	Before  *Space   `protobuf:"bytes,2,opt,name=Before" json:"Before,omitempty"`
	Name    string   `protobuf:"bytes,3,opt,name=Name" json:"Name"`
	Eq      *Keyword `protobuf:"bytes,4,opt,name=Eq" json:"Eq,omitempty"`
	Pattern *Pattern `protobuf:"bytes,5,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *PatternDecl) Reset()                    { *m = PatternDecl{} }
func (*PatternDecl) ProtoMessage()               {}
func (*PatternDecl) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{1} }

func (m *PatternDecl) GetHash() *Keyword {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *PatternDecl) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *PatternDecl) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PatternDecl) GetEq() *Keyword {
	if m != nil {
		return m.Eq
	}
	return nil
}

func (m *PatternDecl) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

// Pattern is the ast node for the union of all possible patterns.
type Pattern struct {
	Empty      *Empty      `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
	TreeNode   *TreeNode   `protobuf:"bytes,3,opt,name=TreeNode" json:"TreeNode,omitempty"`
	LeafNode   *LeafNode   `protobuf:"bytes,4,opt,name=LeafNode" json:"LeafNode,omitempty"`
	Concat     *Concat     `protobuf:"bytes,5,opt,name=Concat" json:"Concat,omitempty"`
	Or         *Or         `protobuf:"bytes,6,opt,name=Or" json:"Or,omitempty"`
	And        *And        `protobuf:"bytes,7,opt,name=And" json:"And,omitempty"`
	ZeroOrMore *ZeroOrMore `protobuf:"bytes,8,opt,name=ZeroOrMore" json:"ZeroOrMore,omitempty"`
	Reference  *Reference  `protobuf:"bytes,9,opt,name=Reference" json:"Reference,omitempty"`
	Not        *Not        `protobuf:"bytes,10,opt,name=Not" json:"Not,omitempty"`
	ZAny       *ZAny       `protobuf:"bytes,11,opt,name=ZAny" json:"ZAny,omitempty"`
	Contains   *Contains   `protobuf:"bytes,12,opt,name=Contains" json:"Contains,omitempty"`
	Optional   *Optional   `protobuf:"bytes,13,opt,name=Optional" json:"Optional,omitempty"`
	Interleave *Interleave `protobuf:"bytes,14,opt,name=Interleave" json:"Interleave,omitempty"`
}

func (m *Pattern) Reset()                    { *m = Pattern{} }
func (*Pattern) ProtoMessage()               {}
func (*Pattern) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{2} }

func (m *Pattern) GetEmpty() *Empty {
	if m != nil {
		return m.Empty
	}
	return nil
}

func (m *Pattern) GetTreeNode() *TreeNode {
	if m != nil {
		return m.TreeNode
	}
	return nil
}

func (m *Pattern) GetLeafNode() *LeafNode {
	if m != nil {
		return m.LeafNode
	}
	return nil
}

func (m *Pattern) GetConcat() *Concat {
	if m != nil {
		return m.Concat
	}
	return nil
}

func (m *Pattern) GetOr() *Or {
	if m != nil {
		return m.Or
	}
	return nil
}

func (m *Pattern) GetAnd() *And {
	if m != nil {
		return m.And
	}
	return nil
}

func (m *Pattern) GetZeroOrMore() *ZeroOrMore {
	if m != nil {
		return m.ZeroOrMore
	}
	return nil
}

func (m *Pattern) GetReference() *Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *Pattern) GetNot() *Not {
	if m != nil {
		return m.Not
	}
	return nil
}

func (m *Pattern) GetZAny() *ZAny {
	if m != nil {
		return m.ZAny
	}
	return nil
}

func (m *Pattern) GetContains() *Contains {
	if m != nil {
		return m.Contains
	}
	return nil
}

func (m *Pattern) GetOptional() *Optional {
	if m != nil {
		return m.Optional
	}
	return nil
}

func (m *Pattern) GetInterleave() *Interleave {
	if m != nil {
		return m.Interleave
	}
	return nil
}

// Empty is the ast node for the Empty pattern.
type Empty struct {
	Empty *Keyword `protobuf:"bytes,1,opt,name=Empty" json:"Empty,omitempty"`
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{3} }

func (m *Empty) GetEmpty() *Keyword {
	if m != nil {
		return m.Empty
	}
	return nil
}

// TreeNode is the ast node for the TreeNode pattern.
type TreeNode struct {
	Name    *NameExpr `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Colon   *Keyword  `protobuf:"bytes,2,opt,name=Colon" json:"Colon,omitempty"`
	Pattern *Pattern  `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *TreeNode) Reset()                    { *m = TreeNode{} }
func (*TreeNode) ProtoMessage()               {}
func (*TreeNode) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{4} }

func (m *TreeNode) GetName() *NameExpr {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *TreeNode) GetColon() *Keyword {
	if m != nil {
		return m.Colon
	}
	return nil
}

func (m *TreeNode) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

// Contains is the ast node for the Contains pattern.
type Contains struct {
	Dot     *Keyword `protobuf:"bytes,1,opt,name=Dot" json:"Dot,omitempty"`
	Pattern *Pattern `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *Contains) Reset()                    { *m = Contains{} }
func (*Contains) ProtoMessage()               {}
func (*Contains) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{5} }

func (m *Contains) GetDot() *Keyword {
	if m != nil {
		return m.Dot
	}
	return nil
}

func (m *Contains) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

// LeafNode is the ast node for the LeafNode pattern.
type LeafNode struct {
	Expr *Expr `protobuf:"bytes,1,opt,name=Expr" json:"Expr,omitempty"`
}

func (m *LeafNode) Reset()                    { *m = LeafNode{} }
func (*LeafNode) ProtoMessage()               {}
func (*LeafNode) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{6} }

func (m *LeafNode) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

// Concat is the ast node for the Concat pattern.
type Concat struct {
	OpenBracket  *Keyword `protobuf:"bytes,2,opt,name=OpenBracket" json:"OpenBracket,omitempty"`
	LeftPattern  *Pattern `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Comma        *Keyword `protobuf:"bytes,4,opt,name=Comma" json:"Comma,omitempty"`
	RightPattern *Pattern `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraComma   *Keyword `protobuf:"bytes,6,opt,name=ExtraComma" json:"ExtraComma,omitempty"`
	CloseBracket *Keyword `protobuf:"bytes,7,opt,name=CloseBracket" json:"CloseBracket,omitempty"`
}

func (m *Concat) Reset()                    { *m = Concat{} }
func (*Concat) ProtoMessage()               {}
func (*Concat) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{7} }

func (m *Concat) GetOpenBracket() *Keyword {
	if m != nil {
		return m.OpenBracket
	}
	return nil
}

func (m *Concat) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Concat) GetComma() *Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Concat) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Concat) GetExtraComma() *Keyword {
	if m != nil {
		return m.ExtraComma
	}
	return nil
}

func (m *Concat) GetCloseBracket() *Keyword {
	if m != nil {
		return m.CloseBracket
	}
	return nil
}

// Or is the ast node for the Or pattern.
type Or struct {
	OpenParen    *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Pipe         *Keyword `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	RightPattern *Pattern `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Or) Reset()                    { *m = Or{} }
func (*Or) ProtoMessage()               {}
func (*Or) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{8} }

func (m *Or) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Or) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Or) GetPipe() *Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *Or) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Or) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// And is the ast node for the And pattern.
type And struct {
	OpenParen    *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	LeftPattern  *Pattern `protobuf:"bytes,2,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	Ampersand    *Keyword `protobuf:"bytes,3,opt,name=Ampersand" json:"Ampersand,omitempty"`
	RightPattern *Pattern `protobuf:"bytes,4,opt,name=RightPattern" json:"RightPattern,omitempty"`
	CloseParen   *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *And) Reset()                    { *m = And{} }
func (*And) ProtoMessage()               {}
func (*And) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{9} }

func (m *And) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *And) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *And) GetAmpersand() *Keyword {
	if m != nil {
		return m.Ampersand
	}
	return nil
}

func (m *And) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *And) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// ZeroOrMore is the ast node for the ZeroOrMore pattern.
type ZeroOrMore struct {
	OpenParen  *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern    *Pattern `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen *Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	Star       *Keyword `protobuf:"bytes,4,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZeroOrMore) Reset()                    { *m = ZeroOrMore{} }
func (*ZeroOrMore) ProtoMessage()               {}
func (*ZeroOrMore) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{10} }

func (m *ZeroOrMore) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *ZeroOrMore) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *ZeroOrMore) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *ZeroOrMore) GetStar() *Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

// Reference is the ast node for the Reference pattern.
type Reference struct {
	At   *Keyword `protobuf:"bytes,1,opt,name=At" json:"At,omitempty"`
	Name string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{11} }

func (m *Reference) GetAt() *Keyword {
	if m != nil {
		return m.At
	}
	return nil
}

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Not is the ast node for the Not pattern.
type Not struct {
	Exclamation *Keyword `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *Keyword `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern     *Pattern `protobuf:"bytes,3,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen  *Keyword `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Not) Reset()                    { *m = Not{} }
func (*Not) ProtoMessage()               {}
func (*Not) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{12} }

func (m *Not) GetExclamation() *Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *Not) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Not) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Not) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// ZAny is the ast node for the ZAny pattern.
type ZAny struct {
	Star *Keyword `protobuf:"bytes,1,opt,name=Star" json:"Star,omitempty"`
}

func (m *ZAny) Reset()                    { *m = ZAny{} }
func (*ZAny) ProtoMessage()               {}
func (*ZAny) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{13} }

func (m *ZAny) GetStar() *Keyword {
	if m != nil {
		return m.Star
	}
	return nil
}

// Optional is the ast node for the Optional pattern.
type Optional struct {
	OpenParen    *Keyword `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Pattern      *Pattern `protobuf:"bytes,2,opt,name=Pattern" json:"Pattern,omitempty"`
	CloseParen   *Keyword `protobuf:"bytes,3,opt,name=CloseParen" json:"CloseParen,omitempty"`
	QuestionMark *Keyword `protobuf:"bytes,4,opt,name=QuestionMark" json:"QuestionMark,omitempty"`
}

func (m *Optional) Reset()                    { *m = Optional{} }
func (*Optional) ProtoMessage()               {}
func (*Optional) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{14} }

func (m *Optional) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Optional) GetPattern() *Pattern {
	if m != nil {
		return m.Pattern
	}
	return nil
}

func (m *Optional) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func (m *Optional) GetQuestionMark() *Keyword {
	if m != nil {
		return m.QuestionMark
	}
	return nil
}

// Interleave is the ast node for the Interleave pattern.
type Interleave struct {
	OpenCurly      *Keyword `protobuf:"bytes,2,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	LeftPattern    *Pattern `protobuf:"bytes,3,opt,name=LeftPattern" json:"LeftPattern,omitempty"`
	SemiColon      *Keyword `protobuf:"bytes,4,opt,name=SemiColon" json:"SemiColon,omitempty"`
	RightPattern   *Pattern `protobuf:"bytes,5,opt,name=RightPattern" json:"RightPattern,omitempty"`
	ExtraSemiColon *Keyword `protobuf:"bytes,6,opt,name=ExtraSemiColon" json:"ExtraSemiColon,omitempty"`
	CloseCurly     *Keyword `protobuf:"bytes,7,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
}

func (m *Interleave) Reset()                    { *m = Interleave{} }
func (*Interleave) ProtoMessage()               {}
func (*Interleave) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{15} }

func (m *Interleave) GetOpenCurly() *Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *Interleave) GetLeftPattern() *Pattern {
	if m != nil {
		return m.LeftPattern
	}
	return nil
}

func (m *Interleave) GetSemiColon() *Keyword {
	if m != nil {
		return m.SemiColon
	}
	return nil
}

func (m *Interleave) GetRightPattern() *Pattern {
	if m != nil {
		return m.RightPattern
	}
	return nil
}

func (m *Interleave) GetExtraSemiColon() *Keyword {
	if m != nil {
		return m.ExtraSemiColon
	}
	return nil
}

func (m *Interleave) GetCloseCurly() *Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

// Expr is a union of all possible expression types, terminal, list, function and builtin function.
type Expr struct {
	RightArrow *Keyword  `protobuf:"bytes,1,opt,name=RightArrow" json:"RightArrow,omitempty"`
	Comma      *Keyword  `protobuf:"bytes,2,opt,name=Comma" json:"Comma,omitempty"`
	Terminal   *Terminal `protobuf:"bytes,3,opt,name=Terminal" json:"Terminal,omitempty"`
	List       *List     `protobuf:"bytes,4,opt,name=List" json:"List,omitempty"`
	Function   *Function `protobuf:"bytes,5,opt,name=Function" json:"Function,omitempty"`
	BuiltIn    *BuiltIn  `protobuf:"bytes,6,opt,name=BuiltIn" json:"BuiltIn,omitempty"`
}

func (m *Expr) Reset()                    { *m = Expr{} }
func (*Expr) ProtoMessage()               {}
func (*Expr) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{16} }

func (m *Expr) GetRightArrow() *Keyword {
	if m != nil {
		return m.RightArrow
	}
	return nil
}

func (m *Expr) GetComma() *Keyword {
	if m != nil {
		return m.Comma
	}
	return nil
}

func (m *Expr) GetTerminal() *Terminal {
	if m != nil {
		return m.Terminal
	}
	return nil
}

func (m *Expr) GetList() *List {
	if m != nil {
		return m.List
	}
	return nil
}

func (m *Expr) GetFunction() *Function {
	if m != nil {
		return m.Function
	}
	return nil
}

func (m *Expr) GetBuiltIn() *BuiltIn {
	if m != nil {
		return m.BuiltIn
	}
	return nil
}

// List is an expression that represents a typed list of expressions.
type List struct {
	Before     *Space     `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Type       types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
	OpenCurly  *Keyword   `protobuf:"bytes,3,opt,name=OpenCurly" json:"OpenCurly,omitempty"`
	Elems      []*Expr    `protobuf:"bytes,4,rep,name=Elems" json:"Elems,omitempty"`
	CloseCurly *Keyword   `protobuf:"bytes,5,opt,name=CloseCurly" json:"CloseCurly,omitempty"`
}

func (m *List) Reset()                    { *m = List{} }
func (*List) ProtoMessage()               {}
func (*List) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{17} }

func (m *List) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *List) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

func (m *List) GetOpenCurly() *Keyword {
	if m != nil {
		return m.OpenCurly
	}
	return nil
}

func (m *List) GetElems() []*Expr {
	if m != nil {
		return m.Elems
	}
	return nil
}

func (m *List) GetCloseCurly() *Keyword {
	if m != nil {
		return m.CloseCurly
	}
	return nil
}

// Function is an expression that represents a function expression, which contains a function name and a list parameters.
type Function struct {
	Before     *Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Name       string   `protobuf:"bytes,2,opt,name=Name" json:"Name"`
	OpenParen  *Keyword `protobuf:"bytes,3,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Params     []*Expr  `protobuf:"bytes,4,rep,name=Params" json:"Params,omitempty"`
	CloseParen *Keyword `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *Function) Reset()                    { *m = Function{} }
func (*Function) ProtoMessage()               {}
func (*Function) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{18} }

func (m *Function) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Function) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Function) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *Function) GetParams() []*Expr {
	if m != nil {
		return m.Params
	}
	return nil
}

func (m *Function) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// BuiltIn is an expression that represents a builtin function.  This is represented by a symbol and an expression.
type BuiltIn struct {
	Symbol *Keyword `protobuf:"bytes,1,opt,name=Symbol" json:"Symbol,omitempty"`
	Expr   *Expr    `protobuf:"bytes,2,opt,name=Expr" json:"Expr,omitempty"`
}

func (m *BuiltIn) Reset()                    { *m = BuiltIn{} }
func (*BuiltIn) ProtoMessage()               {}
func (*BuiltIn) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{19} }

func (m *BuiltIn) GetSymbol() *Keyword {
	if m != nil {
		return m.Symbol
	}
	return nil
}

func (m *BuiltIn) GetExpr() *Expr {
	if m != nil {
		return m.Expr
	}
	return nil
}

// Terminal is an expression that represents a literal value or variable.
type Terminal struct {
	Before      *Space    `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Literal     string    `protobuf:"bytes,2,opt,name=Literal" json:"Literal"`
	DoubleValue *float64  `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue    *int64    `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue   *uint64   `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue   *bool     `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue *string   `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue  []byte    `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
	Variable    *Variable `protobuf:"bytes,50,opt,name=Variable" json:"Variable,omitempty"`
}

func (m *Terminal) Reset()                    { *m = Terminal{} }
func (*Terminal) ProtoMessage()               {}
func (*Terminal) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{20} }

func (m *Terminal) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Terminal) GetLiteral() string {
	if m != nil {
		return m.Literal
	}
	return ""
}

func (m *Terminal) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Terminal) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Terminal) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Terminal) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Terminal) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Terminal) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

func (m *Terminal) GetVariable() *Variable {
	if m != nil {
		return m.Variable
	}
	return nil
}

// Variable is a terminal.
type Variable struct {
	Type types.Type `protobuf:"varint,2,opt,name=Type,enum=types.Type" json:"Type"`
}

func (m *Variable) Reset()                    { *m = Variable{} }
func (*Variable) ProtoMessage()               {}
func (*Variable) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{21} }

func (m *Variable) GetType() types.Type {
	if m != nil {
		return m.Type
	}
	return types.UNKNOWN
}

// Keyword represents any possible keyword.
type Keyword struct {
	Before *Space `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	Value  string `protobuf:"bytes,2,opt,name=Value" json:"Value"`
}

func (m *Keyword) Reset()                    { *m = Keyword{} }
func (*Keyword) ProtoMessage()               {}
func (*Keyword) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{22} }

func (m *Keyword) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Keyword) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Space represents a comment or white space.
type Space struct {
	Space []string `protobuf:"bytes,1,rep,name=Space" json:"Space,omitempty"`
}

func (m *Space) Reset()                    { *m = Space{} }
func (*Space) ProtoMessage()               {}
func (*Space) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{23} }

func (m *Space) GetSpace() []string {
	if m != nil {
		return m.Space
	}
	return nil
}

// NameExpr is a special type of expression for field names that contains a union of all the possible name expressions.
type NameExpr struct {
	Name          *Name          `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	AnyName       *AnyName       `protobuf:"bytes,2,opt,name=AnyName" json:"AnyName,omitempty"`
	AnyNameExcept *AnyNameExcept `protobuf:"bytes,3,opt,name=AnyNameExcept" json:"AnyNameExcept,omitempty"`
	NameChoice    *NameChoice    `protobuf:"bytes,4,opt,name=NameChoice" json:"NameChoice,omitempty"`
}

func (m *NameExpr) Reset()                    { *m = NameExpr{} }
func (*NameExpr) ProtoMessage()               {}
func (*NameExpr) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{24} }

func (m *NameExpr) GetName() *Name {
	if m != nil {
		return m.Name
	}
	return nil
}

func (m *NameExpr) GetAnyName() *AnyName {
	if m != nil {
		return m.AnyName
	}
	return nil
}

func (m *NameExpr) GetAnyNameExcept() *AnyNameExcept {
	if m != nil {
		return m.AnyNameExcept
	}
	return nil
}

func (m *NameExpr) GetNameChoice() *NameChoice {
	if m != nil {
		return m.NameChoice
	}
	return nil
}

// Name is a name expression and represents a union of all possible name type values.
type Name struct {
	Before      *Space   `protobuf:"bytes,1,opt,name=Before" json:"Before,omitempty"`
	DoubleValue *float64 `protobuf:"fixed64,3,opt,name=DoubleValue" json:"DoubleValue,omitempty"`
	IntValue    *int64   `protobuf:"varint,5,opt,name=IntValue" json:"IntValue,omitempty"`
	UintValue   *uint64  `protobuf:"varint,6,opt,name=UintValue" json:"UintValue,omitempty"`
	BoolValue   *bool    `protobuf:"varint,8,opt,name=BoolValue" json:"BoolValue,omitempty"`
	StringValue *string  `protobuf:"bytes,9,opt,name=StringValue" json:"StringValue,omitempty"`
	BytesValue  []byte   `protobuf:"bytes,10,opt,name=BytesValue" json:"BytesValue,omitempty"`
}

func (m *Name) Reset()                    { *m = Name{} }
func (*Name) ProtoMessage()               {}
func (*Name) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{25} }

func (m *Name) GetBefore() *Space {
	if m != nil {
		return m.Before
	}
	return nil
}

func (m *Name) GetDoubleValue() float64 {
	if m != nil && m.DoubleValue != nil {
		return *m.DoubleValue
	}
	return 0
}

func (m *Name) GetIntValue() int64 {
	if m != nil && m.IntValue != nil {
		return *m.IntValue
	}
	return 0
}

func (m *Name) GetUintValue() uint64 {
	if m != nil && m.UintValue != nil {
		return *m.UintValue
	}
	return 0
}

func (m *Name) GetBoolValue() bool {
	if m != nil && m.BoolValue != nil {
		return *m.BoolValue
	}
	return false
}

func (m *Name) GetStringValue() string {
	if m != nil && m.StringValue != nil {
		return *m.StringValue
	}
	return ""
}

func (m *Name) GetBytesValue() []byte {
	if m != nil {
		return m.BytesValue
	}
	return nil
}

// AnyName is a name expression that represents any name.
type AnyName struct {
	Underscore *Keyword `protobuf:"bytes,1,opt,name=Underscore" json:"Underscore,omitempty"`
}

func (m *AnyName) Reset()                    { *m = AnyName{} }
func (*AnyName) ProtoMessage()               {}
func (*AnyName) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{26} }

func (m *AnyName) GetUnderscore() *Keyword {
	if m != nil {
		return m.Underscore
	}
	return nil
}

// AnyNameExpr is a name expression that represents any name except the specified name expression.
type AnyNameExcept struct {
	Exclamation *Keyword  `protobuf:"bytes,1,opt,name=Exclamation" json:"Exclamation,omitempty"`
	OpenParen   *Keyword  `protobuf:"bytes,2,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Except      *NameExpr `protobuf:"bytes,3,opt,name=Except" json:"Except,omitempty"`
	CloseParen  *Keyword  `protobuf:"bytes,4,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *AnyNameExcept) Reset()                    { *m = AnyNameExcept{} }
func (*AnyNameExcept) ProtoMessage()               {}
func (*AnyNameExcept) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{27} }

func (m *AnyNameExcept) GetExclamation() *Keyword {
	if m != nil {
		return m.Exclamation
	}
	return nil
}

func (m *AnyNameExcept) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *AnyNameExcept) GetExcept() *NameExpr {
	if m != nil {
		return m.Except
	}
	return nil
}

func (m *AnyNameExcept) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

// NameChoice is a name expression that represents a choice between two possible name expressions.
type NameChoice struct {
	OpenParen  *Keyword  `protobuf:"bytes,1,opt,name=OpenParen" json:"OpenParen,omitempty"`
	Left       *NameExpr `protobuf:"bytes,2,opt,name=Left" json:"Left,omitempty"`
	Pipe       *Keyword  `protobuf:"bytes,3,opt,name=Pipe" json:"Pipe,omitempty"`
	Right      *NameExpr `protobuf:"bytes,4,opt,name=Right" json:"Right,omitempty"`
	CloseParen *Keyword  `protobuf:"bytes,5,opt,name=CloseParen" json:"CloseParen,omitempty"`
}

func (m *NameChoice) Reset()                    { *m = NameChoice{} }
func (*NameChoice) ProtoMessage()               {}
func (*NameChoice) Descriptor() ([]byte, []int) { return fileDescriptorRelapse, []int{28} }

func (m *NameChoice) GetOpenParen() *Keyword {
	if m != nil {
		return m.OpenParen
	}
	return nil
}

func (m *NameChoice) GetLeft() *NameExpr {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *NameChoice) GetPipe() *Keyword {
	if m != nil {
		return m.Pipe
	}
	return nil
}

func (m *NameChoice) GetRight() *NameExpr {
	if m != nil {
		return m.Right
	}
	return nil
}

func (m *NameChoice) GetCloseParen() *Keyword {
	if m != nil {
		return m.CloseParen
	}
	return nil
}

func init() {
	proto.RegisterType((*Grammar)(nil), "ast.Grammar")
	proto.RegisterType((*PatternDecl)(nil), "ast.PatternDecl")
	proto.RegisterType((*Pattern)(nil), "ast.Pattern")
	proto.RegisterType((*Empty)(nil), "ast.Empty")
	proto.RegisterType((*TreeNode)(nil), "ast.TreeNode")
	proto.RegisterType((*Contains)(nil), "ast.Contains")
	proto.RegisterType((*LeafNode)(nil), "ast.LeafNode")
	proto.RegisterType((*Concat)(nil), "ast.Concat")
	proto.RegisterType((*Or)(nil), "ast.Or")
	proto.RegisterType((*And)(nil), "ast.And")
	proto.RegisterType((*ZeroOrMore)(nil), "ast.ZeroOrMore")
	proto.RegisterType((*Reference)(nil), "ast.Reference")
	proto.RegisterType((*Not)(nil), "ast.Not")
	proto.RegisterType((*ZAny)(nil), "ast.ZAny")
	proto.RegisterType((*Optional)(nil), "ast.Optional")
	proto.RegisterType((*Interleave)(nil), "ast.Interleave")
	proto.RegisterType((*Expr)(nil), "ast.Expr")
	proto.RegisterType((*List)(nil), "ast.List")
	proto.RegisterType((*Function)(nil), "ast.Function")
	proto.RegisterType((*BuiltIn)(nil), "ast.BuiltIn")
	proto.RegisterType((*Terminal)(nil), "ast.Terminal")
	proto.RegisterType((*Variable)(nil), "ast.Variable")
	proto.RegisterType((*Keyword)(nil), "ast.Keyword")
	proto.RegisterType((*Space)(nil), "ast.Space")
	proto.RegisterType((*NameExpr)(nil), "ast.NameExpr")
	proto.RegisterType((*Name)(nil), "ast.Name")
	proto.RegisterType((*AnyName)(nil), "ast.AnyName")
	proto.RegisterType((*AnyNameExcept)(nil), "ast.AnyNameExcept")
	proto.RegisterType((*NameChoice)(nil), "ast.NameChoice")
}
func (m *Grammar) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Grammar) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TopPattern != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.TopPattern.Size()))
		n1, err := m.TopPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.PatternDecls) > 0 {
		for _, msg := range m.PatternDecls {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRelapse(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.After != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.After.Size()))
		n2, err := m.After.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *PatternDecl) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PatternDecl) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Hash != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Hash.Size()))
		n3, err := m.Hash.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Before != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n4, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.Eq != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Eq.Size()))
		n5, err := m.Eq.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Pattern != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n6, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Pattern) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pattern) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Empty.Size()))
		n7, err := m.Empty.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.TreeNode != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.TreeNode.Size()))
		n8, err := m.TreeNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if m.LeafNode != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeafNode.Size()))
		n9, err := m.LeafNode.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Concat != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Concat.Size()))
		n10, err := m.Concat.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Or != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Or.Size()))
		n11, err := m.Or.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.And != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.And.Size()))
		n12, err := m.And.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.ZeroOrMore != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ZeroOrMore.Size()))
		n13, err := m.ZeroOrMore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Reference != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Reference.Size()))
		n14, err := m.Reference.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Not != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Not.Size()))
		n15, err := m.Not.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.ZAny != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ZAny.Size()))
		n16, err := m.ZAny.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.Contains != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Contains.Size()))
		n17, err := m.Contains.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Optional != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Optional.Size()))
		n18, err := m.Optional.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	if m.Interleave != nil {
		dAtA[i] = 0x72
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Interleave.Size()))
		n19, err := m.Interleave.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}

func (m *Empty) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Empty) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Empty != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Empty.Size()))
		n20, err := m.Empty.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}

func (m *TreeNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TreeNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Name.Size()))
		n21, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Colon != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Colon.Size()))
		n22, err := m.Colon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Pattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n23, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *Contains) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contains) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Dot != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Dot.Size()))
		n24, err := m.Dot.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n25, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *LeafNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LeafNode) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Expr != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Expr.Size()))
		n26, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *Concat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Concat) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenBracket != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenBracket.Size()))
		n27, err := m.OpenBracket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n28, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.Comma != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Comma.Size()))
		n29, err := m.Comma.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n30, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	if m.ExtraComma != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ExtraComma.Size()))
		n31, err := m.ExtraComma.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.CloseBracket != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseBracket.Size()))
		n32, err := m.CloseBracket.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *Or) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Or) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n33, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n34, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n34
	}
	if m.Pipe != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pipe.Size()))
		n35, err := m.Pipe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n36, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n37, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	return i, nil
}

func (m *And) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *And) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n38, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n39, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Ampersand != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Ampersand.Size()))
		n40, err := m.Ampersand.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n41, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n42, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	return i, nil
}

func (m *ZeroOrMore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZeroOrMore) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n43, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n44, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n45, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.Star != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Star.Size()))
		n46, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	return i, nil
}

func (m *Reference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Reference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.At != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.At.Size()))
		n47, err := m.At.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	return i, nil
}

func (m *Not) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Not) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exclamation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Exclamation.Size()))
		n48, err := m.Exclamation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.OpenParen != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n49, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.Pattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n50, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n50
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n51, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	return i, nil
}

func (m *ZAny) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ZAny) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Star != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Star.Size()))
		n52, err := m.Star.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n52
	}
	return i, nil
}

func (m *Optional) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Optional) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n53, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n53
	}
	if m.Pattern != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pattern.Size()))
		n54, err := m.Pattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n55, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n55
	}
	if m.QuestionMark != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.QuestionMark.Size()))
		n56, err := m.QuestionMark.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	return i, nil
}

func (m *Interleave) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Interleave) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenCurly != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenCurly.Size()))
		n57, err := m.OpenCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.LeftPattern != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.LeftPattern.Size()))
		n58, err := m.LeftPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.SemiColon != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.SemiColon.Size()))
		n59, err := m.SemiColon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.RightPattern != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightPattern.Size()))
		n60, err := m.RightPattern.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.ExtraSemiColon != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.ExtraSemiColon.Size()))
		n61, err := m.ExtraSemiColon.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n61
	}
	if m.CloseCurly != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseCurly.Size()))
		n62, err := m.CloseCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n62
	}
	return i, nil
}

func (m *Expr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Expr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.RightArrow != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.RightArrow.Size()))
		n63, err := m.RightArrow.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n63
	}
	if m.Comma != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Comma.Size()))
		n64, err := m.Comma.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n64
	}
	if m.Terminal != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Terminal.Size()))
		n65, err := m.Terminal.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n65
	}
	if m.List != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.List.Size()))
		n66, err := m.List.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.Function != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Function.Size()))
		n67, err := m.Function.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.BuiltIn != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.BuiltIn.Size()))
		n68, err := m.BuiltIn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	return i, nil
}

func (m *List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *List) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n69, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(m.Type))
	if m.OpenCurly != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenCurly.Size()))
		n70, err := m.OpenCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if len(m.Elems) > 0 {
		for _, msg := range m.Elems {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRelapse(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloseCurly != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseCurly.Size()))
		n71, err := m.CloseCurly.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n71
	}
	return i, nil
}

func (m *Function) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Function) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n72, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n72
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Name)))
	i += copy(dAtA[i:], m.Name)
	if m.OpenParen != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n73, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n73
	}
	if len(m.Params) > 0 {
		for _, msg := range m.Params {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRelapse(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n74, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n74
	}
	return i, nil
}

func (m *BuiltIn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuiltIn) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Symbol != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Symbol.Size()))
		n75, err := m.Symbol.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n75
	}
	if m.Expr != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Expr.Size()))
		n76, err := m.Expr.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n76
	}
	return i, nil
}

func (m *Terminal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Terminal) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n77, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n77
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Literal)))
	i += copy(dAtA[i:], m.Literal)
	if m.DoubleValue != nil {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i += 8
	}
	if m.IntValue != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		dAtA[i] = 0x40
		i++
		if *m.BoolValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StringValue != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(*m.StringValue)))
		i += copy(dAtA[i:], *m.StringValue)
	}
	if m.BytesValue != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(m.BytesValue)))
		i += copy(dAtA[i:], m.BytesValue)
	}
	if m.Variable != nil {
		dAtA[i] = 0x92
		i++
		dAtA[i] = 0x3
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Variable.Size()))
		n78, err := m.Variable.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n78
	}
	return i, nil
}

func (m *Variable) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Variable) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x10
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *Keyword) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Keyword) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n79, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n79
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRelapse(dAtA, i, uint64(len(m.Value)))
	i += copy(dAtA[i:], m.Value)
	return i, nil
}

func (m *Space) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Space) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Space) > 0 {
		for _, s := range m.Space {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *NameExpr) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameExpr) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Name != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Name.Size()))
		n80, err := m.Name.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.AnyName != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.AnyName.Size()))
		n81, err := m.AnyName.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	if m.AnyNameExcept != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.AnyNameExcept.Size()))
		n82, err := m.AnyNameExcept.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n82
	}
	if m.NameChoice != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.NameChoice.Size()))
		n83, err := m.NameChoice.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n83
	}
	return i, nil
}

func (m *Name) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Name) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Before != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Before.Size()))
		n84, err := m.Before.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n84
	}
	if m.DoubleValue != nil {
		dAtA[i] = 0x19
		i++
		binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(*m.DoubleValue))))
		i += 8
	}
	if m.IntValue != nil {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		dAtA[i] = 0x40
		i++
		if *m.BoolValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.StringValue != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(*m.StringValue)))
		i += copy(dAtA[i:], *m.StringValue)
	}
	if m.BytesValue != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(len(m.BytesValue)))
		i += copy(dAtA[i:], m.BytesValue)
	}
	return i, nil
}

func (m *AnyName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Underscore != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Underscore.Size()))
		n85, err := m.Underscore.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n85
	}
	return i, nil
}

func (m *AnyNameExcept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnyNameExcept) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Exclamation != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Exclamation.Size()))
		n86, err := m.Exclamation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n86
	}
	if m.OpenParen != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n87, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n87
	}
	if m.Except != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Except.Size()))
		n88, err := m.Except.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n89, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	return i, nil
}

func (m *NameChoice) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NameChoice) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.OpenParen != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.OpenParen.Size()))
		n90, err := m.OpenParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.Left != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Left.Size()))
		n91, err := m.Left.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.Pipe != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Pipe.Size()))
		n92, err := m.Pipe.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.Right != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.Right.Size()))
		n93, err := m.Right.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.CloseParen != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRelapse(dAtA, i, uint64(m.CloseParen.Size()))
		n94, err := m.CloseParen.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n94
	}
	return i, nil
}

func encodeVarintRelapse(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Grammar) Size() (n int) {
	var l int
	_ = l
	if m.TopPattern != nil {
		l = m.TopPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if len(m.PatternDecls) > 0 {
		for _, e := range m.PatternDecls {
			l = e.Size()
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	if m.After != nil {
		l = m.After.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *PatternDecl) Size() (n int) {
	var l int
	_ = l
	if m.Hash != nil {
		l = m.Hash.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	if m.Eq != nil {
		l = m.Eq.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Pattern) Size() (n int) {
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.TreeNode != nil {
		l = m.TreeNode.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeafNode != nil {
		l = m.LeafNode.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Concat != nil {
		l = m.Concat.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Or != nil {
		l = m.Or.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.And != nil {
		l = m.And.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ZeroOrMore != nil {
		l = m.ZeroOrMore.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Reference != nil {
		l = m.Reference.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Not != nil {
		l = m.Not.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ZAny != nil {
		l = m.ZAny.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Contains != nil {
		l = m.Contains.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Optional != nil {
		l = m.Optional.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Interleave != nil {
		l = m.Interleave.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Empty) Size() (n int) {
	var l int
	_ = l
	if m.Empty != nil {
		l = m.Empty.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *TreeNode) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Colon != nil {
		l = m.Colon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Contains) Size() (n int) {
	var l int
	_ = l
	if m.Dot != nil {
		l = m.Dot.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *LeafNode) Size() (n int) {
	var l int
	_ = l
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Concat) Size() (n int) {
	var l int
	_ = l
	if m.OpenBracket != nil {
		l = m.OpenBracket.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Comma != nil {
		l = m.Comma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ExtraComma != nil {
		l = m.ExtraComma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseBracket != nil {
		l = m.CloseBracket.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Or) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pipe != nil {
		l = m.Pipe.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *And) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Ampersand != nil {
		l = m.Ampersand.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *ZeroOrMore) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Reference) Size() (n int) {
	var l int
	_ = l
	if m.At != nil {
		l = m.At.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	return n
}

func (m *Not) Size() (n int) {
	var l int
	_ = l
	if m.Exclamation != nil {
		l = m.Exclamation.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *ZAny) Size() (n int) {
	var l int
	_ = l
	if m.Star != nil {
		l = m.Star.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Optional) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pattern != nil {
		l = m.Pattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.QuestionMark != nil {
		l = m.QuestionMark.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Interleave) Size() (n int) {
	var l int
	_ = l
	if m.OpenCurly != nil {
		l = m.OpenCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.LeftPattern != nil {
		l = m.LeftPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.SemiColon != nil {
		l = m.SemiColon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.RightPattern != nil {
		l = m.RightPattern.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.ExtraSemiColon != nil {
		l = m.ExtraSemiColon.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseCurly != nil {
		l = m.CloseCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Expr) Size() (n int) {
	var l int
	_ = l
	if m.RightArrow != nil {
		l = m.RightArrow.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Comma != nil {
		l = m.Comma.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Terminal != nil {
		l = m.Terminal.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.List != nil {
		l = m.List.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Function != nil {
		l = m.Function.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.BuiltIn != nil {
		l = m.BuiltIn.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *List) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	n += 1 + sovRelapse(uint64(m.Type))
	if m.OpenCurly != nil {
		l = m.OpenCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if len(m.Elems) > 0 {
		for _, e := range m.Elems {
			l = e.Size()
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	if m.CloseCurly != nil {
		l = m.CloseCurly.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Function) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Name)
	n += 1 + l + sovRelapse(uint64(l))
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if len(m.Params) > 0 {
		for _, e := range m.Params {
			l = e.Size()
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *BuiltIn) Size() (n int) {
	var l int
	_ = l
	if m.Symbol != nil {
		l = m.Symbol.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Expr != nil {
		l = m.Expr.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Terminal) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Literal)
	n += 1 + l + sovRelapse(uint64(l))
	if m.DoubleValue != nil {
		n += 9
	}
	if m.IntValue != nil {
		n += 1 + sovRelapse(uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		n += 1 + sovRelapse(uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		n += 2
	}
	if m.StringValue != nil {
		l = len(*m.StringValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Variable != nil {
		l = m.Variable.Size()
		n += 2 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Variable) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovRelapse(uint64(m.Type))
	return n
}

func (m *Keyword) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	l = len(m.Value)
	n += 1 + l + sovRelapse(uint64(l))
	return n
}

func (m *Space) Size() (n int) {
	var l int
	_ = l
	if len(m.Space) > 0 {
		for _, s := range m.Space {
			l = len(s)
			n += 1 + l + sovRelapse(uint64(l))
		}
	}
	return n
}

func (m *NameExpr) Size() (n int) {
	var l int
	_ = l
	if m.Name != nil {
		l = m.Name.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.AnyName != nil {
		l = m.AnyName.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.AnyNameExcept != nil {
		l = m.AnyNameExcept.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.NameChoice != nil {
		l = m.NameChoice.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *Name) Size() (n int) {
	var l int
	_ = l
	if m.Before != nil {
		l = m.Before.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.DoubleValue != nil {
		n += 9
	}
	if m.IntValue != nil {
		n += 1 + sovRelapse(uint64(*m.IntValue))
	}
	if m.UintValue != nil {
		n += 1 + sovRelapse(uint64(*m.UintValue))
	}
	if m.BoolValue != nil {
		n += 2
	}
	if m.StringValue != nil {
		l = len(*m.StringValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.BytesValue != nil {
		l = len(m.BytesValue)
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *AnyName) Size() (n int) {
	var l int
	_ = l
	if m.Underscore != nil {
		l = m.Underscore.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *AnyNameExcept) Size() (n int) {
	var l int
	_ = l
	if m.Exclamation != nil {
		l = m.Exclamation.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Except != nil {
		l = m.Except.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func (m *NameChoice) Size() (n int) {
	var l int
	_ = l
	if m.OpenParen != nil {
		l = m.OpenParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Left != nil {
		l = m.Left.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Pipe != nil {
		l = m.Pipe.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.Right != nil {
		l = m.Right.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	if m.CloseParen != nil {
		l = m.CloseParen.Size()
		n += 1 + l + sovRelapse(uint64(l))
	}
	return n
}

func sovRelapse(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRelapse(x uint64) (n int) {
	return sovRelapse(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *Pattern) GetValue() interface{} {
	if this.Empty != nil {
		return this.Empty
	}
	if this.TreeNode != nil {
		return this.TreeNode
	}
	if this.LeafNode != nil {
		return this.LeafNode
	}
	if this.Concat != nil {
		return this.Concat
	}
	if this.Or != nil {
		return this.Or
	}
	if this.And != nil {
		return this.And
	}
	if this.ZeroOrMore != nil {
		return this.ZeroOrMore
	}
	if this.Reference != nil {
		return this.Reference
	}
	if this.Not != nil {
		return this.Not
	}
	if this.ZAny != nil {
		return this.ZAny
	}
	if this.Contains != nil {
		return this.Contains
	}
	if this.Optional != nil {
		return this.Optional
	}
	if this.Interleave != nil {
		return this.Interleave
	}
	return nil
}

func (this *Pattern) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Empty:
		this.Empty = vt
	case *TreeNode:
		this.TreeNode = vt
	case *LeafNode:
		this.LeafNode = vt
	case *Concat:
		this.Concat = vt
	case *Or:
		this.Or = vt
	case *And:
		this.And = vt
	case *ZeroOrMore:
		this.ZeroOrMore = vt
	case *Reference:
		this.Reference = vt
	case *Not:
		this.Not = vt
	case *ZAny:
		this.ZAny = vt
	case *Contains:
		this.Contains = vt
	case *Optional:
		this.Optional = vt
	case *Interleave:
		this.Interleave = vt
	default:
		return false
	}
	return true
}
func (this *NameExpr) GetValue() interface{} {
	if this.Name != nil {
		return this.Name
	}
	if this.AnyName != nil {
		return this.AnyName
	}
	if this.AnyNameExcept != nil {
		return this.AnyNameExcept
	}
	if this.NameChoice != nil {
		return this.NameChoice
	}
	return nil
}

func (this *NameExpr) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *Name:
		this.Name = vt
	case *AnyName:
		this.AnyName = vt
	case *AnyNameExcept:
		this.AnyNameExcept = vt
	case *NameChoice:
		this.NameChoice = vt
	default:
		return false
	}
	return true
}
func (m *Grammar) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Grammar: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Grammar: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TopPattern == nil {
				m.TopPattern = &Pattern{}
			}
			if err := m.TopPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PatternDecls", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PatternDecls = append(m.PatternDecls, &PatternDecl{})
			if err := m.PatternDecls[len(m.PatternDecls)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field After", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.After == nil {
				m.After = &Space{}
			}
			if err := m.After.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PatternDecl) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PatternDecl: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PatternDecl: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Hash == nil {
				m.Hash = &Keyword{}
			}
			if err := m.Hash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Eq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Eq == nil {
				m.Eq = &Keyword{}
			}
			if err := m.Eq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pattern) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pattern: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pattern: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empty == nil {
				m.Empty = &Empty{}
			}
			if err := m.Empty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TreeNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TreeNode == nil {
				m.TreeNode = &TreeNode{}
			}
			if err := m.TreeNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeafNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeafNode == nil {
				m.LeafNode = &LeafNode{}
			}
			if err := m.LeafNode.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Concat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Concat == nil {
				m.Concat = &Concat{}
			}
			if err := m.Concat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Or", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Or == nil {
				m.Or = &Or{}
			}
			if err := m.Or.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field And", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.And == nil {
				m.And = &And{}
			}
			if err := m.And.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZeroOrMore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZeroOrMore == nil {
				m.ZeroOrMore = &ZeroOrMore{}
			}
			if err := m.ZeroOrMore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Reference == nil {
				m.Reference = &Reference{}
			}
			if err := m.Reference.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Not", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Not == nil {
				m.Not = &Not{}
			}
			if err := m.Not.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZAny", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ZAny == nil {
				m.ZAny = &ZAny{}
			}
			if err := m.ZAny.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Contains == nil {
				m.Contains = &Contains{}
			}
			if err := m.Contains.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Optional", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Optional == nil {
				m.Optional = &Optional{}
			}
			if err := m.Optional.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interleave", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interleave == nil {
				m.Interleave = &Interleave{}
			}
			if err := m.Interleave.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Empty) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Empty: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Empty: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Empty", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Empty == nil {
				m.Empty = &Keyword{}
			}
			if err := m.Empty.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TreeNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TreeNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TreeNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &NameExpr{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Colon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Colon == nil {
				m.Colon = &Keyword{}
			}
			if err := m.Colon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contains) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contains: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contains: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Dot == nil {
				m.Dot = &Keyword{}
			}
			if err := m.Dot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LeafNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LeafNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LeafNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Concat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Concat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Concat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenBracket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenBracket == nil {
				m.OpenBracket = &Keyword{}
			}
			if err := m.OpenBracket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comma == nil {
				m.Comma = &Keyword{}
			}
			if err := m.Comma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraComma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraComma == nil {
				m.ExtraComma = &Keyword{}
			}
			if err := m.ExtraComma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseBracket", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseBracket == nil {
				m.CloseBracket = &Keyword{}
			}
			if err := m.CloseBracket.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Or) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Or: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Or: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipe == nil {
				m.Pipe = &Keyword{}
			}
			if err := m.Pipe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *And) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: And: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: And: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ampersand", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Ampersand == nil {
				m.Ampersand = &Keyword{}
			}
			if err := m.Ampersand.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZeroOrMore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZeroOrMore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZeroOrMore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &Keyword{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Reference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field At", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.At == nil {
				m.At = &Keyword{}
			}
			if err := m.At.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Not) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Not: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Not: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclamation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exclamation == nil {
				m.Exclamation = &Keyword{}
			}
			if err := m.Exclamation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ZAny) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ZAny: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ZAny: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Star", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Star == nil {
				m.Star = &Keyword{}
			}
			if err := m.Star.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Optional) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Optional: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Optional: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pattern == nil {
				m.Pattern = &Pattern{}
			}
			if err := m.Pattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QuestionMark", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QuestionMark == nil {
				m.QuestionMark = &Keyword{}
			}
			if err := m.QuestionMark.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Interleave) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Interleave: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Interleave: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCurly == nil {
				m.OpenCurly = &Keyword{}
			}
			if err := m.OpenCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeftPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.LeftPattern == nil {
				m.LeftPattern = &Pattern{}
			}
			if err := m.LeftPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemiColon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SemiColon == nil {
				m.SemiColon = &Keyword{}
			}
			if err := m.SemiColon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightPattern", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightPattern == nil {
				m.RightPattern = &Pattern{}
			}
			if err := m.RightPattern.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExtraSemiColon", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ExtraSemiColon == nil {
				m.ExtraSemiColon = &Keyword{}
			}
			if err := m.ExtraSemiColon.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseCurly == nil {
				m.CloseCurly = &Keyword{}
			}
			if err := m.CloseCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Expr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Expr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Expr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightArrow", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RightArrow == nil {
				m.RightArrow = &Keyword{}
			}
			if err := m.RightArrow.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Comma", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Comma == nil {
				m.Comma = &Keyword{}
			}
			if err := m.Comma.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminal", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Terminal == nil {
				m.Terminal = &Terminal{}
			}
			if err := m.Terminal.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field List", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.List == nil {
				m.List = &List{}
			}
			if err := m.List.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Function", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Function == nil {
				m.Function = &Function{}
			}
			if err := m.Function.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuiltIn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuiltIn == nil {
				m.BuiltIn = &BuiltIn{}
			}
			if err := m.BuiltIn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (types.Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenCurly == nil {
				m.OpenCurly = &Keyword{}
			}
			if err := m.OpenCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Elems", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Elems = append(m.Elems, &Expr{})
			if err := m.Elems[len(m.Elems)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseCurly", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseCurly == nil {
				m.CloseCurly = &Keyword{}
			}
			if err := m.CloseCurly.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Function) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Function: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Function: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = append(m.Params, &Expr{})
			if err := m.Params[len(m.Params)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuiltIn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuiltIn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuiltIn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Symbol == nil {
				m.Symbol = &Keyword{}
			}
			if err := m.Symbol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expr", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Expr == nil {
				m.Expr = &Expr{}
			}
			if err := m.Expr.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Terminal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Terminal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Terminal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Literal", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Literal = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntValue = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UintValue = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BoolValue = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StringValue = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesValue = append(m.BytesValue[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesValue == nil {
				m.BytesValue = []byte{}
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Variable", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Variable == nil {
				m.Variable = &Variable{}
			}
			if err := m.Variable.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Variable) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Variable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Variable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (types.Type(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Keyword) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Keyword: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Keyword: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Space) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Space: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Space: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Space", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Space = append(m.Space, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameExpr) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameExpr: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameExpr: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Name == nil {
				m.Name = &Name{}
			}
			if err := m.Name.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyName == nil {
				m.AnyName = &AnyName{}
			}
			if err := m.AnyName.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnyNameExcept", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnyNameExcept == nil {
				m.AnyNameExcept = &AnyNameExcept{}
			}
			if err := m.AnyNameExcept.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameChoice", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameChoice == nil {
				m.NameChoice = &NameChoice{}
			}
			if err := m.NameChoice.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Name) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Name: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Name: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Before", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Before == nil {
				m.Before = &Space{}
			}
			if err := m.Before.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field DoubleValue", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			v2 := float64(math.Float64frombits(v))
			m.DoubleValue = &v2
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IntValue", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IntValue = &v
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UintValue", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UintValue = &v
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BoolValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.BoolValue = &b
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StringValue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.StringValue = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BytesValue = append(m.BytesValue[:0], dAtA[iNdEx:postIndex]...)
			if m.BytesValue == nil {
				m.BytesValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Underscore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Underscore == nil {
				m.Underscore = &Keyword{}
			}
			if err := m.Underscore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnyNameExcept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnyNameExcept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnyNameExcept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exclamation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Exclamation == nil {
				m.Exclamation = &Keyword{}
			}
			if err := m.Exclamation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Except", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Except == nil {
				m.Except = &NameExpr{}
			}
			if err := m.Except.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NameChoice) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NameChoice: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NameChoice: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OpenParen == nil {
				m.OpenParen = &Keyword{}
			}
			if err := m.OpenParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Left == nil {
				m.Left = &NameExpr{}
			}
			if err := m.Left.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pipe", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pipe == nil {
				m.Pipe = &Keyword{}
			}
			if err := m.Pipe.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Right == nil {
				m.Right = &NameExpr{}
			}
			if err := m.Right.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CloseParen", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelapse
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CloseParen == nil {
				m.CloseParen = &Keyword{}
			}
			if err := m.CloseParen.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelapse(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRelapse
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRelapse(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRelapse
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelapse
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthRelapse
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRelapse
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRelapse(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRelapse = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRelapse   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("relapse.proto", fileDescriptorRelapse) }

var fileDescriptorRelapse = []byte{
	// 1441 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x58, 0x4f, 0x6f, 0x1b, 0xc5,
	0x1b, 0xee, 0xae, 0xd7, 0x76, 0xfc, 0x3a, 0x49, 0x7f, 0x1a, 0x55, 0xfa, 0xad, 0xa2, 0xd6, 0x75,
	0xb7, 0xb4, 0x0a, 0xa5, 0x24, 0x25, 0xaa, 0x04, 0xe2, 0x66, 0xbb, 0x06, 0x22, 0xd2, 0x24, 0x4c,
	0xda, 0x1e, 0x7a, 0x9b, 0xd8, 0x93, 0x64, 0xd5, 0xf5, 0xee, 0x76, 0x76, 0x4c, 0xe3, 0x2b, 0x5f,
	0x00, 0x3e, 0x01, 0xe2, 0xcc, 0x09, 0x09, 0x21, 0x6e, 0x08, 0x21, 0x21, 0xf5, 0xc0, 0xa1, 0x47,
	0x4e, 0x08, 0x82, 0xc4, 0x8d, 0x23, 0x77, 0x34, 0x7f, 0x76, 0x77, 0xd6, 0xdd, 0x38, 0x0e, 0x52,
	0x25, 0xb8, 0x38, 0xbb, 0xcf, 0xf3, 0xec, 0xcc, 0xbc, 0xcf, 0xbc, 0xf3, 0xce, 0x4c, 0x60, 0x89,
	0xd1, 0x80, 0xc4, 0x09, 0x5d, 0x8b, 0x59, 0xc4, 0x23, 0x54, 0x21, 0x09, 0x5f, 0x79, 0xf3, 0xd0,
	0xe7, 0x47, 0xe3, 0xfd, 0xb5, 0x41, 0x34, 0x5a, 0x3f, 0x8c, 0x0e, 0xa3, 0x75, 0xc9, 0xed, 0x8f,
	0x0f, 0xe4, 0x9b, 0x7c, 0x91, 0x4f, 0xea, 0x9b, 0x95, 0xbb, 0x86, 0xfc, 0x09, 0xe1, 0x93, 0xa1,
	0x3f, 0xcc, 0xfe, 0xea, 0xd6, 0xd7, 0xf9, 0x24, 0xa6, 0x89, 0xfa, 0x55, 0x5f, 0x79, 0x9f, 0x5a,
	0x50, 0x7f, 0x9f, 0x91, 0xd1, 0x88, 0x30, 0x74, 0x1b, 0xe0, 0x41, 0x14, 0xef, 0x12, 0xce, 0x29,
	0x0b, 0x5d, 0xab, 0x6d, 0xad, 0x36, 0x37, 0x16, 0xd7, 0x48, 0xc2, 0xd7, 0x34, 0x86, 0x0d, 0x1e,
	0xdd, 0x85, 0x45, 0xfd, 0x78, 0x8f, 0x0e, 0x82, 0xc4, 0xb5, 0xdb, 0x95, 0xd5, 0xe6, 0xc6, 0xff,
	0x4c, 0xbd, 0x20, 0x70, 0x41, 0x85, 0xda, 0x50, 0xed, 0x1c, 0x70, 0xca, 0xdc, 0x8a, 0x6c, 0x1e,
	0xa4, 0x7c, 0x2f, 0x26, 0x03, 0x8a, 0x15, 0xe1, 0x7d, 0x6d, 0x41, 0xd3, 0xf8, 0x04, 0xb5, 0xc1,
	0xf9, 0x80, 0x24, 0x47, 0x85, 0xf1, 0x7c, 0x48, 0x27, 0xcf, 0x22, 0x36, 0xc4, 0x92, 0x41, 0x1e,
	0xd4, 0xba, 0xf4, 0x20, 0x62, 0xd4, 0xb5, 0x5f, 0x6a, 0x54, 0x33, 0xc8, 0x05, 0x67, 0x9b, 0x8c,
	0xa8, 0xec, 0xb6, 0xd1, 0x75, 0x9e, 0xff, 0x72, 0xf5, 0x02, 0x96, 0x08, 0xba, 0x0c, 0x76, 0xff,
	0xa9, 0xeb, 0x94, 0xb4, 0x6e, 0xf7, 0x9f, 0xa2, 0x9b, 0x50, 0x4f, 0x0d, 0xa9, 0x96, 0x18, 0x92,
	0x92, 0xde, 0x27, 0x4e, 0x26, 0x14, 0x31, 0xf6, 0x47, 0x31, 0x9f, 0xe8, 0x21, 0xab, 0xe1, 0x48,
	0x04, 0x2b, 0x02, 0xbd, 0x0e, 0x0b, 0x0f, 0x18, 0xa5, 0xdb, 0xd1, 0x90, 0x6a, 0x23, 0x96, 0xa4,
	0x28, 0x05, 0x71, 0x46, 0x0b, 0xe9, 0x16, 0x25, 0x07, 0x52, 0xea, 0x18, 0xd2, 0x14, 0xc4, 0x19,
	0x8d, 0xae, 0x43, 0xad, 0x17, 0x85, 0x03, 0xc2, 0xf5, 0x50, 0x9b, 0x52, 0xa8, 0x20, 0xac, 0x29,
	0xf4, 0x7f, 0xb0, 0x77, 0x98, 0x5b, 0x93, 0x82, 0xba, 0x14, 0xec, 0x30, 0x6c, 0xef, 0x30, 0xb4,
	0x02, 0x95, 0x4e, 0x38, 0x74, 0xeb, 0x92, 0x59, 0x90, 0x4c, 0x27, 0x1c, 0x62, 0x01, 0xa2, 0x75,
	0x80, 0xc7, 0x94, 0x45, 0x3b, 0xec, 0xbe, 0x70, 0x79, 0x41, 0x4a, 0x2e, 0x4a, 0x49, 0x0e, 0x63,
	0x43, 0x82, 0x6e, 0x43, 0x03, 0xd3, 0x03, 0xca, 0x68, 0x38, 0xa0, 0x6e, 0x43, 0xea, 0x97, 0xa5,
	0x3e, 0x43, 0x71, 0x2e, 0x10, 0x5d, 0x6f, 0x47, 0xdc, 0x05, 0xa3, 0xeb, 0xed, 0x88, 0x63, 0x01,
	0xa2, 0x2b, 0xe0, 0x3c, 0xee, 0x84, 0x13, 0xb7, 0x29, 0xc9, 0x86, 0xea, 0xb4, 0x13, 0x4e, 0xb0,
	0x84, 0x85, 0x3d, 0xbd, 0x28, 0xe4, 0xc4, 0x0f, 0x13, 0x77, 0xd1, 0xb0, 0x27, 0x05, 0x71, 0x46,
	0x0b, 0xe9, 0x4e, 0xcc, 0xfd, 0x28, 0x24, 0x81, 0xbb, 0x64, 0x48, 0x53, 0x10, 0x67, 0xb4, 0x88,
	0x77, 0x33, 0xe4, 0x94, 0x05, 0x94, 0x7c, 0x4c, 0xdd, 0x65, 0x23, 0xde, 0x1c, 0xc6, 0x86, 0xe4,
	0x5d, 0xe7, 0xf9, 0x17, 0x57, 0x2d, 0xef, 0x0d, 0x3d, 0xf1, 0xc8, 0x2b, 0x66, 0x40, 0x31, 0xad,
	0x14, 0xe5, 0x4d, 0xf2, 0x1c, 0x40, 0xd7, 0x74, 0x76, 0x5a, 0xc6, 0xb0, 0x04, 0xd0, 0x3f, 0x8e,
	0x99, 0x4e, 0x53, 0x0f, 0xaa, 0xbd, 0x28, 0x88, 0x42, 0x9d, 0xe3, 0x53, 0x4d, 0x4a, 0xca, 0x4c,
	0xd6, 0xca, 0xac, 0x64, 0xc5, 0xb9, 0x69, 0xa8, 0x05, 0x95, 0x7b, 0x11, 0x2f, 0x1d, 0xa8, 0x20,
	0xcc, 0x36, 0xed, 0x59, 0x6d, 0x1a, 0x79, 0x2a, 0xe6, 0x4c, 0x8c, 0x5c, 0x37, 0xaa, 0xe6, 0x4c,
	0x85, 0x22, 0x7e, 0xbd, 0xcf, 0xed, 0x34, 0x51, 0xd1, 0x1a, 0x34, 0x77, 0x62, 0x1a, 0x76, 0x19,
	0x19, 0x3c, 0xa1, 0xbc, 0x34, 0x36, 0x53, 0x20, 0xf4, 0x5b, 0xf4, 0x80, 0xcf, 0x8a, 0xd2, 0x14,
	0x28, 0xd7, 0x46, 0x23, 0x52, 0xba, 0xbe, 0x15, 0x85, 0xee, 0xc0, 0x22, 0xf6, 0x0f, 0x8f, 0xf8,
	0xac, 0x75, 0x5e, 0x50, 0x88, 0x42, 0xd9, 0x3f, 0xe6, 0x8c, 0xa8, 0xa6, 0x6b, 0x25, 0x4d, 0x1b,
	0xbc, 0x68, 0xbf, 0x17, 0x44, 0x09, 0x4d, 0x83, 0xac, 0x97, 0xe8, 0x0b, 0x0a, 0xef, 0xc4, 0x12,
	0x8b, 0x14, 0xdd, 0x82, 0x86, 0x88, 0x7d, 0x97, 0x30, 0x1a, 0x96, 0x4e, 0x50, 0x4e, 0x4f, 0x1b,
	0x63, 0x9f, 0x65, 0x4c, 0x1b, 0x9c, 0x5d, 0x3f, 0xa6, 0x05, 0x07, 0xb3, 0xaa, 0x2a, 0x98, 0x97,
	0x6c, 0x71, 0xe6, 0xb1, 0x45, 0x86, 0xa1, 0x06, 0x5c, 0x2d, 0xb3, 0x25, 0xe7, 0xbd, 0x3f, 0x2d,
	0x59, 0x70, 0x5e, 0x69, 0x94, 0xb7, 0xa0, 0xd1, 0x19, 0xc5, 0x94, 0x25, 0x24, 0x1c, 0x96, 0x86,
	0x9a, 0xd3, 0xaf, 0x3c, 0xde, 0xaf, 0x2c, 0xb3, 0x88, 0x9e, 0x2b, 0xec, 0x39, 0xd7, 0xe0, 0xd4,
	0x80, 0x2a, 0xb3, 0x07, 0x24, 0x52, 0x60, 0x8f, 0x13, 0x56, 0xba, 0x34, 0x24, 0xe3, 0xf5, 0x8c,
	0x2a, 0x2e, 0xf6, 0xc9, 0x4e, 0x79, 0x9d, 0xb0, 0x3b, 0x3c, 0xdb, 0x5f, 0xed, 0xe9, 0xfd, 0xd5,
	0xfb, 0xd6, 0x92, 0xd5, 0x5d, 0xcc, 0x5d, 0xff, 0x78, 0x10, 0x90, 0x11, 0x11, 0x45, 0xb6, 0xb4,
	0x21, 0x53, 0x50, 0x34, 0xc8, 0x9e, 0xdb, 0xa0, 0xca, 0xfc, 0x06, 0x39, 0x67, 0xcc, 0xd8, 0xaa,
	0xda, 0x7a, 0x32, 0xa3, 0xac, 0x53, 0x8d, 0xfa, 0xce, 0xca, 0xf7, 0x96, 0x7f, 0xc1, 0xcc, 0xde,
	0x81, 0xc5, 0x8f, 0xc6, 0x34, 0x11, 0xe3, 0xb9, 0x4f, 0xd8, 0x93, 0xd2, 0x40, 0x0b, 0x0a, 0xef,
	0x4b, 0xdb, 0xdc, 0xf1, 0xd2, 0x10, 0x7a, 0x63, 0x16, 0x4c, 0x4e, 0xf7, 0x5e, 0xd2, 0xe7, 0x2e,
	0xc9, 0xb7, 0xa0, 0xb1, 0x47, 0x47, 0xbe, 0xda, 0xcc, 0xca, 0x46, 0x96, 0xd3, 0xff, 0xa0, 0x34,
	0xdf, 0x85, 0x65, 0x59, 0x7a, 0xf3, 0x2e, 0xca, 0xca, 0xf3, 0x94, 0x26, 0xb3, 0x57, 0x05, 0x5c,
	0x3f, 0xd5, 0x5e, 0xc9, 0x7b, 0x7f, 0x59, 0x6a, 0x7f, 0x13, 0x9f, 0xc9, 0xce, 0x3b, 0x8c, 0x45,
	0xcf, 0x4a, 0xa7, 0xda, 0xe0, 0xf3, 0xbd, 0xc8, 0x3e, 0x7d, 0x2f, 0x12, 0x07, 0x43, 0xca, 0x46,
	0xbe, 0x38, 0xa3, 0x14, 0x0e, 0x86, 0x1a, 0xc4, 0x19, 0x2d, 0x36, 0xd9, 0x2d, 0x3f, 0xe1, 0xda,
	0x42, 0xb5, 0xc9, 0x0a, 0x00, 0x4b, 0x58, 0xb4, 0xf4, 0xde, 0x38, 0x1c, 0xc8, 0xb5, 0x56, 0x35,
	0x5a, 0x4a, 0x41, 0x9c, 0xd1, 0x22, 0x09, 0xbb, 0x63, 0x3f, 0xe0, 0x9b, 0x45, 0xb3, 0x34, 0x86,
	0x53, 0xd2, 0xfb, 0xc9, 0x52, 0x5d, 0x1a, 0x07, 0x6e, 0xeb, 0xd4, 0x03, 0xf7, 0x0d, 0x70, 0x1e,
	0x4c, 0x62, 0x55, 0x10, 0x96, 0x37, 0x9a, 0x6b, 0xea, 0xd2, 0x21, 0xa0, 0xb4, 0x3a, 0x88, 0xe7,
	0x62, 0xa6, 0x55, 0x66, 0x67, 0xda, 0x55, 0xa8, 0xf6, 0x03, 0x3a, 0x4a, 0x5c, 0x47, 0x5e, 0x35,
	0x8c, 0x73, 0x85, 0xc2, 0xa7, 0xa6, 0xb1, 0x7a, 0xc6, 0x34, 0xfe, 0x68, 0xe5, 0x16, 0xcd, 0x15,
	0xd2, 0xa9, 0x35, 0xae, 0xb8, 0xe4, 0x2b, 0xb3, 0x97, 0xfc, 0x35, 0xa8, 0xed, 0x12, 0x46, 0xca,
	0xc2, 0xd0, 0xc4, 0x39, 0x37, 0x96, 0xed, 0x6c, 0xfa, 0xd0, 0x6b, 0x50, 0xdb, 0x9b, 0x8c, 0xf6,
	0xa3, 0xa0, 0x34, 0x19, 0x35, 0x97, 0x1d, 0xcf, 0xec, 0xf2, 0xe3, 0xd9, 0x37, 0x76, 0x9e, 0x84,
	0x73, 0xf9, 0xd2, 0x82, 0xfa, 0x96, 0xcf, 0x29, 0x23, 0x41, 0xc1, 0x9a, 0x14, 0x44, 0x6d, 0x68,
	0xde, 0x8b, 0xc6, 0xfb, 0x01, 0x7d, 0x44, 0x82, 0xb1, 0x3a, 0x72, 0x58, 0xd8, 0x84, 0xd0, 0x0a,
	0x2c, 0x6c, 0x86, 0x5c, 0xd1, 0x22, 0xdc, 0x0a, 0xce, 0xde, 0xd1, 0x65, 0x68, 0x3c, 0xf4, 0x53,
	0x52, 0xe4, 0xa7, 0x83, 0x73, 0x40, 0xb0, 0xdd, 0x28, 0x0a, 0x14, 0x2b, 0x2e, 0x26, 0x0b, 0x38,
	0x07, 0x44, 0xcf, 0x7b, 0x9c, 0xf9, 0xe1, 0xa1, 0xe2, 0xc5, 0x45, 0xa4, 0x81, 0x4d, 0x08, 0xb5,
	0x00, 0xba, 0x13, 0x4e, 0x13, 0x25, 0x10, 0x37, 0x90, 0x45, 0x6c, 0x20, 0x62, 0x19, 0x3d, 0x22,
	0xcc, 0x27, 0xfb, 0x01, 0x75, 0x37, 0x8c, 0x65, 0x94, 0x82, 0x38, 0xa3, 0xbd, 0xb7, 0x72, 0xe9,
	0x9c, 0xd9, 0xef, 0x6d, 0x42, 0x5d, 0x4f, 0xce, 0x5c, 0x46, 0xaf, 0x40, 0x55, 0x8d, 0xd3, 0xb4,
	0x59, 0x41, 0xde, 0x15, 0xa8, 0x4a, 0x31, 0xba, 0xa4, 0x1f, 0x5c, 0xab, 0x5d, 0x59, 0x6d, 0x60,
	0xf5, 0xe2, 0xfd, 0x60, 0xc1, 0x42, 0x7a, 0xa3, 0x10, 0x09, 0x60, 0x5c, 0x37, 0x1a, 0xd9, 0x75,
	0x43, 0x67, 0xf3, 0x4d, 0xa8, 0x77, 0xc2, 0x49, 0x96, 0xea, 0x69, 0x1a, 0x69, 0x0c, 0xa7, 0x24,
	0x7a, 0x07, 0x96, 0xf4, 0x63, 0xff, 0x78, 0x40, 0x63, 0xae, 0x33, 0x1f, 0x99, 0x6a, 0xc5, 0xe0,
	0xa2, 0x50, 0xdc, 0xaf, 0xc4, 0x5b, 0xef, 0x28, 0xf2, 0x07, 0xe9, 0xb5, 0xf6, 0x62, 0x36, 0x0c,
	0x05, 0x63, 0x43, 0xa2, 0xef, 0x57, 0x7f, 0x58, 0x90, 0x5e, 0x86, 0xce, 0x36, 0xeb, 0x3f, 0x9c,
	0x75, 0xde, 0xdb, 0xd9, 0x0c, 0x88, 0x5a, 0xf0, 0x30, 0x1c, 0x52, 0x96, 0x0c, 0xf2, 0x70, 0xa7,
	0x6a, 0x41, 0xce, 0x7b, 0xdf, 0x5b, 0x53, 0x73, 0xf2, 0x4a, 0x8f, 0x5d, 0x37, 0xa0, 0x56, 0x98,
	0xf9, 0xa9, 0x8b, 0xab, 0x26, 0xcf, 0x79, 0xea, 0x7a, 0x61, 0x99, 0xc9, 0x71, 0xae, 0xd3, 0xd4,
	0x35, 0x70, 0xc4, 0x49, 0x43, 0x0f, 0x7b, 0xfa, 0x1a, 0x2d, 0xa8, 0x39, 0xee, 0x3d, 0xd7, 0xa1,
	0x2a, 0x37, 0xed, 0xc2, 0x7f, 0x5b, 0xb2, 0x56, 0x14, 0x77, 0xbe, 0x0a, 0xdd, 0xbd, 0xf4, 0xf3,
	0x6f, 0xad, 0x0b, 0xcf, 0x4f, 0x5a, 0xd6, 0x8b, 0x93, 0x96, 0xf5, 0xeb, 0x49, 0xcb, 0xfa, 0xec,
	0xf7, 0xd6, 0x85, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf5, 0x4c, 0x2a, 0x63, 0xf4, 0x13, 0x00,
	0x00,
}
